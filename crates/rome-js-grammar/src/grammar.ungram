// Rules
// Create a node when:
// - contains multiple children (not just a token)
// - it is part of an union type over nodes  
// otherwise, create a token

// Create a wrapper node when the optionality of two or more children depend on each other.
// - For example, the 'else' token and the alternate branch must either be both present or absent. 
//      -> Create an ElseClause wrapping the token and the alternate branch. 
// Create a wrapper node for lists of children that use a common separator, for example
//   `ArrayElement = value: Expression, trailing_comma: ','`
//   This to guarantee that all tokens can be accessed and that you have a single type of children nodes


// Rules across all nodes
// * Prefix with 'Js'
// * Don't abbreviate names, Expr -> Expression, Stmt -> Statement, Decl -> Declaration, Fn -> Function... 

// Questions
// - Should we prefix tokens like `;`, `if` that are simple character sequences -> NO? They all share the same semantics, even if they differ in casing (e.g. `true` vs `True` vs `TRUE`)
// - Split different expressions: Unary/Binary/Update by operator. Roslyn has PreIncrementExpression, PreDecrementExpression, AddExpression, etc. Makes it easier to match for a specific node without having to match on the token as well. 
//                                but results in many more nodes. Main advantage if you want to query. Hey, I'm interested in all add expressions -> node.descendants::<BinaryAddExpression>() vs node.descendants::<BinaryExpression>().filter(|n| n.operator() == '++');
// - Unify JsScript and JsModule? Or do we need it because we currently can't store any additional meta data on nodes. If we keep it, add a `JsRoot` that holds the shared fields?
// - RSLint has a JsCondition='(' JsExpression ')' that is used in If/While/Do-While and Switch statements. Should we keep it? No -> Unnecessary nesting? Same for formal parameters
// - Conformance of the AST: A few examples -> NO? 
//   - if (test) var a = 10; is legit whereas if (test) let a = 10; isn't 
//   - using import/export only allowed inside of a module
//   - contextual keywords. E.g. await expression outside of async functions. 
// - should the parser generate a JsNode and JsToken type that is a union over all nodes/tokens? -> Yes?
// - when should the optional trailing comma be part of the element (e.g. array) or should the element have a value that's over a union type
// - Decide on member/property naming. ClassMember, MemberExpression (but uses object and property)
// - revisit to see if we can extract more shared nodes, for example a type for all parameters
// - ungrammer extensions / syntax generator:
//      - add support for /// comments to ungrammar and expose them in the parser for documentation?
//      - add support for + qualifier
//      - support labels (interpreter: 'js_shebang')
//      - Automatically strip 'Js' prefix from methods (so that we can remove many of the labels)
//      - Support union types (e.g. don't generate multiple operator fields for the binary expression operators)
//      - Generate different return types for mandatory/optional nodes
// - Commas are annoying. Not always allowed (e.g. setter param). Roslyn has SeparatedList. Unclear how this would work with missing separators (or can we assume the parser never inserts separators)? and from a typing


JsScript = 
    interpreter: 'js_shebang'? // rslint: shebang
    directives: 'js_directive'* // Or a directive node? 
    stmts: JsStatement* // Called items

JsModule = 
    interpreter: 'js_shebang'?
    directives: 'js_directive'*
    stmts: JsStatement* 

// --------------------- Unknowns ---------------------
// Hack to make ungrammar happy. Let's hope they never ban recursive types xD
// Add special handling in the source generator to skip the `SyntaxNode`, `SyntaxToken`, and `SyntaxElement` types, so that they resolve to the global `SyntaxNode`, `SyntaxToken`, and `SyntaxElement` definitions.
SyntaxNode = SyntaxNode
SyntaxToken = SyntaxToken
SyntaxElement = SyntaxNode | SyntaxToken

JsUnknownStatement = SyntaxElement*
JsUnknownExpression = SyntaxElement*
JsUnknownPattern = SyntaxElement*
JsUnknownMember = SyntaxElement*

// --------------------- Statements ---------------------

                                        // RSLint
JsStatement = JsBlockStatement          // BlockStmt
    | JsBreakStatement                  // BreakStmt
    | JsClassDeclaration                // ClassDecl
    | JsDebuggerStatement               // DebuggerStmt
    | JsEmptyStatement                  // EmptyStmt
    | JsExpressionStatement             // ExprStmt 
    | JsForStatement                    // ForStmt
    | JsForInStatement                  // ForInStmt
    | JsForOfStatement                  // ForOfStmt
    | JsFunctionDeclaration             // FnDecl
    | JsIfStatement                     // IfStmt
    | JsLabeledStatement                // LabelledStmt
    | JsReturnStatement                 // ReturnStmt
    | JsSwitchStatement                 // SwitchStmt
    | JsTryStatement                    // TryStmt
    | JsVariableDeclarationStatement    // VarDecl
    | JsWhileStatement                  // WhileStmt
    | JsWithStatement                   // WithStmt
    | JsExport                          // ExportDecl
    | JsExportDefault                   // ExportDefaultDecl
    | JsExportFrom                      // ExportNamed
    | JsExportAllFrom                   // ExportWildcard
    | JsImport                          // ??
    | JsImportModule                    // ??
    | JsUnknownStatement

JsBlockStatement = 
    '{' stmts: JsStatement* '}'

JsBreakStatement = 
    'break' 
    (label: 'js_identifier')? 
    ';'?

JsContinueStatement = 
    'continue' 
    (label: 'js_identifier')? 
    ';'?

JsDebuggerStatement = 
    'debugger' ';'?

// RSLint uses Condition for: (test)
JsDoWhileStatement = 
    'do' body: JsStatement 
    'while' '(' test: JsExpression ')' ';'?

JsEmptyStatement = 
    ';'

JsExpressionStatement =
    expression: JsExpression ';'?

// Difference to RSLint: no ForInit, ForTest and ForUpdate: RSLint needed the extra kinds so that it could keep the test/update apart
JsForStatement = 
    'for' '(' 
    init: JsForInit? init_semicolon: ';' 
    test: JsExpression? test_semicolon: ';' 
    update: JsExpression? 
    ')' 
    body: JsStatement

JsForInit = JsExpression
    | JsVariableDeclaration

JsForInStatement = 
    'for' '(' left: JsForLeft 'in' right: JsExpression ')' 
    body: JsStatement

// Separate `ForAwait?` 
JsForOfStatement = 
    'for' 'await'? 
    '(' left: JsForLeft 'of' right: JsExpression ')' 
    body: JsStatement

JsForLeft = JsVariableDeclaration |  JsAssignmentTarget

JsFunctionDeclaration = 
    'function' '*'? id: JsBindingIdentifier 
    parameter_list: JsParameterList
    body: JsFunctionBody

// Doesn't exist in Rome, rome uses the same type for block/function bodies. 
// Reason for splitting: Directives can only exist in function bodies (anything introducing new scope)
JsFunctionBody = 
    '{' 
    directives: 'directive'*  
    body: JsStatement* 
    '}'

JsIfStatement = 
    'if' '(' test: JsExpression ')' 
    consequence: JsStatement 
    else_clause: JsElseClause?

JsElseClause = 
    'else'
    alternate: JsStatement

JsLabeledStatement = 
    label: 'js_identifier' ':' 
    body: JsStatement

JsReturnStatement = 
    'return' argument: JsExpression? ';'?

JsSwitchStatement = 
    'switch' '(' discriminant: JsExpression ')' 
    cases: JsSwitchCase*

// Introduce a case clause / default because the optionality of the tokens depend on which variant it is
JsSwitchCase = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: JsExpression ':'
JsDefaultClause = 'default' ':'

JsThrowStatement = 
    'throw' argument: JsExpression ';'?

JsTryStatement = 
    'try' 
    block: JsBlockStatement
    catch_clause: JsCatchClause

// Having a `JsTryStatement` and a `JsTryFinallyStatement` isn't ideal because passes must query both if they want to handle try statements. 
// Alternatives are
// - Keep single `JsTryStatement` type that contains a list of `try_handlers`+. less guarantess about the handlers
// - Keep single `JsTryStatement` type but create a `TryHandler = CatchClause | FinallyClause | CatchFinallyClause` node so that users can match the whole try statement. 
JsTryFinallyStatement = 
    'try'
    block: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

// Group catch parameters because '(', parameter, ')' are all either optional or mandatory depending if any of them are
JsCatchClause = 
    'catch' 
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration = 
    '(' binding: JsBinding ')'

JsFinallyClause = 
    'finally'
    body: JsBlockStatement

JsVariableDeclarationStatement = 
    declaration: JsVariableDeclaration ';'?

// TODO unable to type: at least one child. Add support for + (at least one) to ungrammar or split into declarator: JsVariableDeclarator, other_declarators: JsVariableDeclarator*
JsVariableDeclaration = 
    kind_token: ('var' | 'let' | 'const') 
    declarators: JsVariableDeclarator*

JsVariableDeclarator = 
    id: JsBinding '=' init: JsExpression?

JsWhileStatement = 
    'while' '(' test: JsExpression ')' 
    body: JsStatement

JsWithStatement = 
    'with' '(' object: JsExpression ')' 
    body: JsStatement

// --------------------- EXPRESSIONS ---------------------

// enum Expr {
//     NewTarget, // new.target not supported 
//     ImportMeta, // import.meta not supported
//     SuperCall,  -> CallExpression
//     PrivatePropAccess, -> MemberExpression
// }
                                        // RSLint Name
JsExpression = JsArrayExpression        // ArrayExpr
    | JsArrowFunctionExpression         // ArrowExpr
    | JsAssignmentExpression            // AssignExpr
    | JsAwaitExpression                 // AwaitExpr
    | JsBinaryExpression                // BinExpr
    | JsCallExpression                  // CallExpr
    | JsClassExpression                 // ClassExpr
    | JsConditionalExpression           // CondExpr
    | JsDoExpression
    | JsFunctionExpression              // FnExpr
    | JsImportCall                      // ImportCall
    | JsLogicalExpression               // BinExp
    | JsMemberExpression                // DotExpr, BracketExpr
    | JsNewExpression                   // NewExpr
    | JsObjectExpression                // ObjectExpr
    | JsOptionalCallExpression          // CallExpr -> with access to optional token
    | JsParenthesizedExpression         // GroupingExpr
    | JsReferenceIdentifierExpression   // NameRef (Rome: JsReferenceIdentifier, Shift: IdentifierExpression)
    | JsSequenceExpression              // SeqExpr
    | JsSuperExpression                 // Super  -> Shift doesn't model Super as expression, I guess to make it sure that it is only allowed in very specific places (call expressions, member object etc. Might be worth making the same distingshen)
    | JsTaggedTemplateExpression        // TemplateString
    | JsThisExpression                  // This
    | JsUnaryExpression                 // UnaryExpression, covers `await` as well... but why does RSlint have await expression and the unary expression with await??
    | JsPreUpdateExpression             // UnaryExpression (Rome: JsUpdateExpression)
    | JsPostUpdateExpression            // UnaryExpression (Rome: JsUpdateExpression)
    | JsYieldExpression                 // YieldExpr
    | JsBooleanLiteral                  // Literal
    | JsBigIntLiteral                   // Literal
    | JsNullLiteral                     // Literal
    | JsNumberLiteral                   // Literal
    | JsStringLiteral                   // Literal
    | JsTemplateLiteral                 
    | JsUnknownExpression

JsArrayExpression = 
    '[' 
    elements: AnyJsArrayElement* 
    ']'

// Doesn't exist in Rome classic nor RSLint. Required so that we can refer the ',' token
AnyJsArrayElement = JsArraySpreadElement
    | JsArrayElement 
    | JsArrayHole

JsArraySpreadElement = 
    '...' argument: JsExpression
    trailing_comma: ','?

JsArrayElement = 
    expression: JsExpression 
    trailing_comma: ','?

JsArrayHole = comma: ','

JsArrowFunctionExpression = 
    'async'? 
    parameters: JsArrowFunctionParameters 
    '=>' 
    body: JsStatementOrExpression 

JsArrowFunctionParameters = JsParameterList | JsParameter

JsStatementOrExpression = JsStatement | JsExpression

// Split out Compound assignment for the "updating" operators because the left must then be a JsSimpleAssignmentTarget???
JsAssignmentExpression = 
    left: JsAssignmentTarget
    operator: ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '>>>=' | '|=' | '^=' | '&=' | '**=' | '&&=' | '||=' | '??=') 
    right: JsExpression

JsAwaitExpression = 
    'await' argument: JsExpression

JsBinaryExpression = 
    left: JsExpression 
    operator: ('==' | '!=' | '===' | '**' | '!==' | '<' | '<=' | '>' | '>=' | '<<' | '>>' | '>>>' | '+' | '-' | '*' | '/' | '%' | '|' | '^' | '&' | 'in' | 'instanceof') 
    right: JsExpression

// Rome classic adds super to calle but this isn't needed since super is an expression???
JsCallExpression = 
    callee: JsExpression 
    '(' arguments: JsCallArgument* ')'

JsCallArgument = 
    value: JsExpressionOrSpread trailing_comma: ','?

JsExpressionOrSpread = JsExpression | JsSpread

JsConditionalExpression = 
    test: JsExpression 
    '?' 
    consequent: JsExpression 
    ':' 
    alternate: JsExpression

JsDoExpression = 
    'do'
    body: JsBlockStatement

JsFunctionExpression = 
    'async'? 
    'function' 
    '*'? 
    id: JsBindingIdentifier? 
    parameter_list: JsParameterList
    body: JsFunctionBody

JsLogicalExpression = 
    left: JsExpression 
    operator: ('||' | '&&' | '??') 
    right: JsExpression


// Rome classic defines object as expr | super but super is already expression?
JsMemberExpression = 
    object: JsExpression 
    member: JsMember

JsMember = JsStaticMember | JsComputedMember 

JsStaticMember = '.' name: JsStaticMemberName

// We should implement helpers that convert the content to a valid key, e.g. the key 0x02 = '2' and not '0x02'
JsStaticMemberName = JsIdentifier | JsStringLiteral | JsNumberLiteral

JsComputedMember = '[' name: JsExpression ']'


// Rome classic defines callee as expr | super but super is an expression? 
JsNewExpression = 
    'new' 
    callee: JsExpression 
    '(' arguments: JsCallArgument* ')'

// TODO Better to have a OptionalExpression type to support arrays, members, calls, template literal, private identifier
JsOptionalCallExpression = 
    optional: '?.' 
    '(' arguments: JsCallArgument* ')'

JsParenthesizedExpression = 
    '(' expression: JsExpression ')'

JsReferenceIdentifierExpression = 
    name: 'js_identifier'

// Even a + qualifier isn't sufficient. We have the following options to represent sequences in the AST:
// - first, second, ...rest: 
// - specify that the parser never generates a sequence expression if there are less than 2 expressions. In that case, expressions* would be safe. `a,` would be parsed as unknown expression
// - Model as `BinaryExpression` where `,` is the operator. Results in deeper trees but at least, can be modelled correctly. a, b, c -> seq(left: seq(a, b), c)
JsSequenceExpression = 
    left: JsExpression 
    comma: ',' 
    second: JsExpression

JsSuperExpression = 'super'

// example`test`
JsTaggedTemplateExpression = 
    tag: JsExpression
    literal: JsTemplateLiteral

JsThisExpression = 'this'

JsUnaryExpression = 
    operator: ('-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete')? 
    argument: JsExpression

// Pre/Post are needed to make the `operator` accessor mandatory. The only alternative would be to
// `JsUpdateExpression = **internal**_prefix: (...)? argument: JsExpression **internal**_postfix: (...)?` and then 
// define a public facing `operator` method that returns either one of them or missing if the operator isn't present at all
// (which is unlikely, because the parser would then just parse the argument)
JsPreUpdateExpression = 
    operator: ('--' | '++') 
    operand: JsSimpleAssignmentTarget

JsPostUpdateExpression = 
    operand: JsSimpleAssignmentTarget 
    operator: ('--' | '++')

JsYieldExpression = 
    'yield' '*'? 
    argument: JsExpression?

// --------------------- LITERALS ---------------------

// RSLint uses a single literal node for all kinds. I believe having different nodes is beneficial because it allows us to 
// add helper methods on the corresponding `AstNode`s. For example, to get the representation of a number literal, testing
// if a boolean is true, getting the unquoted string... 
// All the literal could implement a `Literal` trait that provides access to the "raw" value 

// "abcd" | 'abcd'
JsStringLiteral = value: 'js_string'

// 4, 5.5, 0x00, ...
JsNumberLiteral = value: 'js_number' // Called JsNumericLiteral in Rome, helper for retrieving representation (hex|octal| etc)

// 45n
JsBigIntLiteral =  value: 'js_big_int' // should the `n` be part of the big_int token or not? Should quotes be part of a string token? -> 5.5d is a numeric_token in roslyn

// true, false
JsBooleanLiteral = value: ('true' | 'false')

// null
JsNullLiteral = value: 'null'

// TODO RegEx

// The contents of the template. This list must be alternating TemplateElements and Expressions, beginning and ending with TemplateElement.
// Parser guarantees that this list is never empty, always contains at least on element
// Rome uses two different lists: expressions and quasis 
JsTemplateLiteral =  
    left_tick: '`' 
    elements: JsTemplateElement* 
    right_tick: '`'

JsTemplateElement = JsStringTemplateElement | JsExpression

JsStringTemplateElement = value: 'js_string_template_element'


// --------------------- CLASSES ---------------------

// RSLint: ClassDecl, has ClassBody type
// Rome calls the "members" body. Introduce `ClassBody`? 
JsClassDeclaration = 
    'class' 
    id: JsBindingIdentifier 
    extends_clause: JsExtendsClause? 
    '{' members: JsClassMember* '}'

JsExtendsClause = 
    'extends' 
    super_class: JsExpression

JsClassExpression = 
    'class' 
    id: JsBindingIdentifier? 
    extends_clause: JsExtendsClause? 
    '{' members: JsClassMember* '}' 

JsClassMember =                      // RSLint 
    JsConstructorClassMember         // Constructor
    | JsPropertyClassMember          // ClassProp
    | JsPrivatePropertyClassMember   // PrivateProp
    | JsMethodClassMember            // Method
    | JsGetterClassMember            // Getter
    | JsSetterClassMember            // Setter
    | JsUnknownMember

// Main reason for splitting: Each of these have different requirements. For example, a setter without an argument is a syntax error but it's totally fine for a method
// We need to encode this into the grammar to ensure accessing the values will yield an Error when apporpriate.
// At the other hand, the fact that get doesn't accept a param means that we need to fallback to `UnknownMember` when someone creates a getter that accepts an argument. BUT, no one would ever visit the params of the getter and, therefore, are not aware of the syntax error.

// Explicit constructor required because TS constructor support additional visibility modifiers that methods don't. 
JsConstructorClassMember = 
    'constructor' 
    parameter_list: JsParameterList
    body: JsFunctionBody

JsClassMemberName = JsObjectMemberKey | JsPrivateClassMemberName

JsPropertyClassMember = 
    'static' 
    key: JsClassMemberName 
    value: JsPropertyClassMemberInitializer? ';'

JsPropertyClassMemberInitializer = 
    '=' expression: JsExpression

// TODO share methods etc with objects?
JsMethodClassMember = 
    'static'? 
    'async'? 
    '*'? 
    key: JsClassMemberName 
    parameter_list: JsParameterList
    body: JsFunctionBody

JsGetterClassMember = 
    'static'? 
    'get' 
    key: JsClassMemberName 
    '(' ')'  
    body: JsFunctionBody

JsSetterClassMember = 
    'static'? 
    'set' 
    key: JsClassMemberName 
    '(' value: JsParameter ')' 
    body: JsFunctionBody

JsPrivateClassMemberName = '#' id: 'js_identifier'

JsPrivateMethodClassMember = 
    'static'? 
    'async'? 
    '*'? 
    key: JsPrivateClassMemberName 
    parameter_list: JsParameterList
    body: JsFunctionBody

JsPrivatePropertyClassMember = 
    'static' 
    key: JsPrivateClassMemberName 
    value: JsPropertyClassMemberInitializer? ';'


// --------------------- OBJECTS ---------------------

// members = properties in Rome classic
JsObjectExpression = 
    '{' members: JsObjectMember* '}'



// TODO inline union type or change generator to automatically unroll union types used in another union type, because having to match twice is rather annoying
JsObjectMemberKey =  JsStaticMemberName | JsComputedMember

                                                // RSLint
JsObjectMember = JsMethodObjectMember           // Method, shared with class (allows static, object doesn't allow private names, trailing comma)
 | JsGetterObjectMember                         // Getter, shared with class
 | JsSetterObjectMember                         // Setter, shared with class
 | JsPropertyObjectMember                       // LiteralProp? 
 | JsSpreadObjectMember                         // SpreadProp (Rome: JsSpreadProperty)
 | JsUnknownMember

JsPropertyObjectMember = 
    key: JsObjectMemberKey 
    ':' 
    value: JsExpression 
    trailing_comma: ','

JsMethodObjectMember = 
    'async'? 
    '*'? 
    key: JsObjectMemberKey 
    parameter_list: JsParameterList
    body: JsFunctionBody 
    trailing_comma: ','

JsGetterObjectMember = 
    'get' 
    key: JsObjectMemberKey 
    '(' ')' 
    body: JsFunctionBody
    trailing_comma: ','

JsSetterObjectMember = 
    'set' 
    key: JsObjectMemberKey 
    '(' value: JsParameter ')' 
    body: JsFunctionBody 
    trailing_comma: ','

JsSpreadObjectMember = 
    '...' argument: JsExpression 
    trailing_comma: ','


// --------------------- MODULES ---------------------

JsExport = 
    'export' declaration: JsExportDeclaration
    ';'?

JsExportDeclaration = JsFunctionDeclaration | JsClassDeclaration | JsVariableDeclarationStatement

JsExportFrom =
    'export'
    '{'
        specifiers: JsExportFromSpecifier*
    '}'
    'from'
    module_specifier: JsStringLiteral
    ';'?

JsExportFromSpecifier = 
    name: JsIdentifier 
    export_name: JsExportName?
    trailing_comma: ','?

JsExportName = 
    'as' name: JsIdentifier

JsExportDefault = 
    'export' 'default' argument: JsExportDefaultArgument

JsExportDefaultArgument = JsClassDeclaration | JsFunctionDeclaration | JsExportDefaultExpressionArgument
// TODO: Replace with expression statement? It has the same structure, it's just a different name. 
// Spec doesn't allow arbitrary expressions
JsExportDefaultExpressionArgument = expression: JsExpression ';'?

JsExportAllFrom = 
    'export' 
    '*' export_name: JsExportName? 
    'from' source: JsStringLiteral 
    ';'?

JsImportModule = 
    'import'
    module_specifier: JsStringLiteral
    ';'?

JsImport = 
    'import' 
    clause: JsImportClause
    'from'
    module_specifier: JsStringLiteral
    ';'?

// Needed to guarantee we only allow valid combinations which are
// - default: import x from 'a'
// - named: import { a } from 'a';
// - namespace: import * from 'a';
// - default + namespace: import x, * as a from 'a'
// - default + named: import x, { a } from 'a'
JsImportClause = JsImportDefaultBinding | JsNamespaceImportClause | JsNamedImportClause

// Rome wrapps the local name in JSImportSpecifierLocal
JsImportDefaultBinding = 
    local_name: JsBindingIdentifier
    // TODO, the comma is required if followed by a {} but otherwise forbidden
    trailing_comma: ','?

// Flatten the 'as' + name or use 'JsImportBinding'?
JsNamespaceImportClause = 
    default_binding: JsImportDefaultBinding?
    '*'
    'as'
    name: JsBindingIdentifier

JsNamedImportClause = 
    default_binding: JsImportDefaultBinding?
    '{'
    named_imports: JsImportSpecifier*
    '}'

JsImportSpecifier = 
    name: JsIdentifier
    binding: JsImportBinding?
    trailing_comma: ','?

JsImportBinding = 
    'as' name: JsBindingIdentifier

JsImportCall = 
    'import'
    '('
    argument: JsExpression
    ')'

// --------------------- Bindings ---------------------

// Bindings introduce new variables. These can be variable declarations or patterns
// ```
// let x = 10; // x is a binding identifier
// let { x, y: [a] } = { x: 1, y: [0] }, // x, introduces the new bindings x and a
// ```

JsBinding = JsObjectBinding | JsArrayBinding | JsBindingIdentifier 

JsDefaultValueClause = 
    '=' 
    value: JsExpression
    
// let x = OR function(test) {}
//     ^               ^^^^
JsBindingIdentifier = name: 'js_identifier'

// let [a, b] = test
//     ^^^^^^
JsArrayBinding = 
    '['
    elements: AnyJsArrayBindingElement*
    rest: JsArrayRestBinding?
    ']'

AnyJsArrayBindingElement = JsArrayHole | JsArrayBindingElement

JsArrayBindingElement = 
    binding: JsBinding 
    default_value: JsDefaultValueClause
    trailing_comma: ','?

JsArrayRestBinding = 
    '...'
    binding: JsBinding


// let {a, b, ...rest } = 
//     ^^^^^^^^^^^^^^^^
JsObjectBinding = 
    '{'
        properties: AnyJsPropertyBinding*
        rest: JsObjectRestBinding?
    '}'

// The approach of Babel/Rome to have a single property binding that uses the binding as the key if absent doesn't work because
// serializing that tree would result in a different source text (one that uses a:a)
AnyJsPropertyBinding = JsShorthandPropertyBinding | JsPropertyBinding

// let { x } or let { x = "test" }
JsShorthandPropertyBinding = 
    identifier: JsBindingIdentifier
    default_value: JsDefaultValueClause?
    trailing_comma: ','?

// let { x: a } or let { x: a = "test" }
// JsDestructuredPropertyBinding
JsPropertyBinding = 
    member: JsMember
    ':'
    binding: JsBinding
    default_value: JsDefaultValueClause?
    trailing_comma: ','?


JsObjectRestBinding = '...' binding: JsBindingIdentifier

// --------------------- Assignment targets  ---------------------


JsSimpleAssignmentTarget = JsMemberAssignmentTarget | JsIdentifierAssignmentTarget

JsAssignmentTarget = JsSimpleAssignmentTarget | JsArrayAssignmentTarget | JsObjectAssignmentTarget

// b = "test"
// ^
JsIdentifierAssignmentTarget = name: 'js_identifier'

// a.b = a['b'] = "test"
// ^^^   ^^^^^^
JsMemberAssignmentTarget = 
    object: JsExpression
    member: JsMember

// [a, {b}, ...rest] = test
// ^^^^^^^^^^^^^^^^^
JsArrayAssignmentTarget = 
    '['
        elements: AnyJsArrayAssignmentTargetElement*
        rest: JsArrayAssignmentRest?
    ']'

JsArrayAssignmentRest = 
    '...' 
    target: JsAssignmentTarget

AnyJsArrayAssignmentTargetElement = JsArrayHole | JsArrayAssignmentTargetElement

JsArrayAssignmentTargetElement = 
    target: JsAssignmentTarget 
    default_value: JsDefaultValueClause
    trailing_comma: ','?

// {a, b: x, ...rest} = 
// ^^^^^^^^^^^^^^^^^^
JsObjectAssignmentTarget = 
    '{'
        properties: JsPropertyAssignmentTarget*
        rest: JsObjectRestAssignmentTarget?
    '}'

JsPropertyAssignmentTarget = JsShorthandPropertyAssignmentTarget | JsObjectPropertyAssignmentTarget

// { x } or { x = "test" }
JsShorthandPropertyAssignmentTarget = 
    identifier: JsIdentifierAssignmentTarget
    default_value: JsDefaultValueClause?
    trailing_comma: ','?

// let { x: a } or let { x: a = "test" }
// JsDestructuredPropertyBinding
JsObjectPropertyAssignmentTarget = 
    member: JsMember
    ':'
    target: JsAssignmentTarget
    default_value: JsDefaultValueClause?
    trailing_comma: ','?

JsObjectRestAssignmentTarget = '...' target: JsSimpleAssignmentTarget                                           

// --------------------- Auxilary ---------------------

// We can implement various helpers on the function union to replace `FunctionHead` (without paying for the abstraction)
JsFunction = JsFunctionDeclaration 
    | JsFunctionExpression 
    | JsArrowFunctionExpression

JsParameterList = 
    '('
    parameters: JsParameter*
    rest: JsRestParameter?
    ')'

JsParameter = 
    binding: JsBinding
    default: JsDefaultValueClause?
    trailing_comma: ','

JsRestParameter = '...' binding: JsBinding

JsIdentifier = 
    name: 'js_identifier'

JsSpread = 
    '...' argument: JsExpression
